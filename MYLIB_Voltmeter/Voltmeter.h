/**
	Voltmeter_h - библиотека, позволяющая представить отдельный аналоговый пин, как вольтметр с делителем.
	Имеется внутренний фильтр значений с усреднением, позволяющий получить точный усреднённый результат даже тогда, когда производится измерение нестабильного
	источника напряжения с пульсациями.
	Плюс именно данной библиотеки в том, что вследствие прямой работы с регистрами микроконтроллера, его скорость даже с использованием усреднения весьма высока, 
	а размер при этом сильно уменьшается. Используется функция фонового преобразования, что позволяет измерять напряжение за 104 микросекунды даже при большом
	(до 80) количестве выборок, а при использовании тактовой частоты АЦП 4МГц снижается до 12 микросекунд! При измерении на одну выборку тратится 1,44 микросекунды.
	Однако учтите, что основные операции с фильтрацией производятся в методе getVoltage, поэтому большое количество выборок не только сильно увеличивает размер занимаемой 
	оперативной памяти, но и негативно сказывается на скорости получения напряжения и, отчасти, на скорости его измерения.
	
	При создании указывается:
		* Пин, на котором будет висеть вольтметр.
		* Необязательный параметр - опорное напряжение АЦП
		* Необязательный параметр - сопротивление верхнего резистора делителя
		* Необязательный параметр - сопротивление нижнего резистора делителя
		* Необязательный параметр - количество выборок для стабилизации/фильтрации значений
		* Необязательный параметр - пороговый разброс между выборками. Если 0 - то будет искать одинаковые

	Если при создании указать только пин, вольтметр будет измерять текущее фактическое напряжение на указанном выводе, используя в качестве опорного напряжения 5 вольт.
	Если дополнительно указать и опорное напряжение, то результат будет рассчитываться исходя из него.
	Внимание: переключение регистра выбора опорного напряжения АЦП зависит от выбранного опорного напряжения. Если вы указали 1.1 или 5 вольт, то будут использоваться:
		В первом  случае - внутренний источник опорного напряжения 1.1 вольт
		Во втором случае - напряжение на пине AVcc, который на ардуино по умолчанию подключён к напряжению питания 5 вольт.
		Во всех остальных случаях будет использовано напряжение на пине ARef
	В качестве опорного напряжения лучше устанавливать внутреннее напряжение контроллера (1.1v), так как оно более стабильно.
	СТАНДАРТНАЯ ФУНКЦИЯ АРДУИНО analogReference() НЕ ВЛИЯЕТ НА ДАННУЮ БИБЛИОТЕКУ!!! Это позволяет устанавливать разные опорные напряжения для разных пинов, делая вольтметр ещё более 
	гибким в использовании! Однако, тут есть и минусы:
	Если вы используете несколько вольтметров в одной программе, и у них разные источники опорного напряжения, то в силу особенностей АЦП, первые измерения (порядка 30 раз) после 
	смены источника будут совершенно неточными. Для исправления данного недостатка, в библиотеке реализован автоматический калибратор, но он выключен по умолчанию, так как 
	измерение займёт в 30 раз больше времени!!! Для его включения, вызовите один раз функцию enableREFcalibrationPass(). Вы также можете передать ей количество 
	проходов для калибрации. По умолчанию: 30.
	Включение данной функции сильно замедлит работу вольтметра. Для компенсации потери скорости вы можете увеличить тактовую частоту АЦП.
	
	Если вы хотите изменить скорость преобразования/включить прерывания по завершению преобразования, либо произвести иные манипуляции с регистром ADCSRA, используйте метод
	set_CTRL_STAT_REG_VAL(byte new_ADCSRA_val), принимающий байтовое значение, которое будет записываться в регистр каждый раз при произведении измерения.
	Для удобства, данная библиотека имеет шаблонные значения, позволяющие задать определённую тактовую частоту АЦП:
		ADC_RATE_125KHz - по умолчанию используемое стандартными библиотеками. Время измерения: 208 микросекунд
		ADC_RATE_250KHz - по умолчанию используемое данной библиотекой. Время измерения: 104 микросекунды
		ADC_RATE_500KHz - Время измерения: 56 микросекунд
		ADC_RATE_1MHz - Время измерения: 28 микросекунд
		ADC_RATE_2MHz - Время измерения: 16 микросекунд
		ADC_RATE_4MHz - Время измерения: 12 микросекунд
		ADC_RATE_8MHz - Возможно, не работает. АЦП всё время возвращает 1023. Время измерения: 8 микросекунд
		
	Данные частоты будет верны, если используется 16MHz кварцевый резонатор. При использовании другой тактовой частоты, частота АЦП изменяется пропорционально.
	Примечание: при использовании более высокой тактовой частоты, точность АЦП будет уменьшаться!
	
	Для проведения измерений напряжения большего, чем опорное, необходимо сделать резистивный делитель, а в конструкторе вводятся параметры верхнего и нижнего резистора.
	Можно дополнительно изменить количество выборок. Если необходимо отключить фильтрацию - укажите 1. В дополнение, можно изменить пороговый разброс при фильтрации.
	Также, изменение количества выборок и разброса возможно методом setFilterSamplesCount(byte countOfSamples, byte filterRange). 
	
	Для того, чтобы узнать верхнюю границу вольтметра с определёнными параметрами, используйте эту формулу:
	|-------------------------------|
	|	REF / (R2 / ( R1 + R2 ) )	|
	|-------------------------------|
	Где REF - опорное напряжение, а R1 и R2 - параметры верхнего и нижнего резисторов делителя соответственно.
	Для проведения очередного измерения и учёта его результата в усреднённом напряжении, в цикле/таймере/отдельном потоке вызывается метод processMeasurement()
	Для того, чтобы узнать текущий уровень напряжения на этом выводе, вызывается метод getVoltage().
	Начало положено by ExtNeon. 05.11.2017
*/

// проверка, что библиотека еще не подключена
#ifndef Voltmeter_h // если библиотека не подключена
#define Voltmeter_h // тогда подключаем ее

#if defined (__AVR_ATmega328__) || defined (__AVR_ATmega328P__) || defined(__AVR_ATmega168__) || defined(__AVR_ATmega88__) 

#define shl(x) ((x << 1) | (x >> 7)) //Cyclic shift bits in byte to the left
#define shr(x) ((x >> 1) | (x << 7)) //Cyclic shift bits in byte to the right

#define ADC_RATE_125KHz B11000111
#define ADC_RATE_250KHz B11000110 //ADC ENABLE | ADC START CONVERSION | ADC Auto Trigger DISABLE | ADC Interrupt Flag DISABLE | ADC Interrupt DISABLE | PRESCALER SET TO 64
#define ADC_RATE_500KHz B11000101
#define ADC_RATE_1MHz B11000100
#define ADC_RATE_2MHz B11000011
#define ADC_RATE_4MHz B11000010
#define ADC_RATE_8MHz B11000001

#include "Arduino.h"
#include <avr/io.h>

class Voltmeter {
	public:
		Voltmeter(byte measurement_Pin, float ctrl_ref_voltage = 5., float rdiv_TopResistance = 0, float rdiv_BottomResistance = 1, byte filterCountOfSamples = 3, byte filterRange = 12);
		void setDividerParams(float rdiv_TopResistance, float rdiv_BottomResistance, float ctrl_ref_voltage);
		void setFilterSamplesCount(byte countOfSamples, byte filterRange);
		float getVoltage();
		void processMeasurement();
		void set_CTRL_STAT_REG_VAL(byte new_ADCSRA_val);
		void enableREFcalibrationPass(byte amountOfPasses = 30);
	private:
		void AnReadStart();
		uint16_t AnReadEnd();
		boolean isADCReadInProcess();
		byte _pin;
		//short *dev_vlmSumValue;
		byte dev_maxFilterSamplesCount; //Максимальное количество сложений для усреднения
		word* samples = NULL;
		//int dev_countOfMeasures = 0;
		//short dev_sum = 0;
		double dev_transferCoeff;
		boolean dev_changed = true;
		float dev_lastResult;
		byte _filterRange;
		byte dev_ctrl_stat_reg = ADC_RATE_250KHz; 
		byte _EXP_DEV_ENABLE_CALIBRATION_PASS_AMNT = 0;
		
};
#else
#error  Ваш контроллер библиотекой Voltmeter Registers Operation не поддерживается
#endif
#endif